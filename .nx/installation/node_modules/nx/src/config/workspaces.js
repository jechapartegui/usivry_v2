"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.renamePropertyWithStableKeys = exports.readTargetDefaultsForTarget = exports.mergeTargetConfigurations = exports.buildProjectsConfigurationsFromProjectPaths = exports.inferProjectFromNonStandardFile = exports.deduplicateProjectFiles = exports.getGlobPatternsFromPackageManagerWorkspaces = exports.getGlobPatternsFromPluginsAsync = exports.getGlobPatternsFromPlugins = exports.toProjectName = exports.Workspaces = void 0;
const tslib_1 = require("tslib");
const fs_1 = require("fs");
const path = require("path");
const path_1 = require("path");
const workspace_root_1 = require("../utils/workspace-root");
const fileutils_1 = require("../utils/fileutils");
const logger_1 = require("../utils/logger");
const nx_plugin_1 = require("../utils/nx-plugin");
const nx_json_1 = require("./nx-json");
const output_1 = require("../utils/output");
const path_2 = require("../utils/path");
const angular_json_1 = require("../adapter/angular-json");
const retrieve_workspace_files_1 = require("../project-graph/utils/retrieve-workspace-files");
class Workspaces {
    constructor(root) {
        this.root = root;
    }
    relativeCwd(cwd) {
        return path.relative(this.root, cwd).replace(/\\/g, '/') || null;
    }
    /**
     * @deprecated
     */
    readProjectsConfigurations(opts) {
        if (this.cachedProjectsConfig &&
            process.env.NX_CACHE_PROJECTS_CONFIG !== 'false') {
            return this.cachedProjectsConfig;
        }
        const nxJson = (0, nx_json_1.readNxJson)(this.root);
        const projectPaths = (0, retrieve_workspace_files_1.retrieveProjectConfigurationPaths)(this.root, nxJson);
        let projectsConfigurations = buildProjectsConfigurationsFromProjectPaths(nxJson, projectPaths, (path) => (0, fileutils_1.readJsonFile)((0, path_1.join)(this.root, path)));
        if ((0, angular_json_1.shouldMergeAngularProjects)(this.root, opts === null || opts === void 0 ? void 0 : opts._includeProjectsFromAngularJson)) {
            projectsConfigurations = (0, angular_json_1.mergeAngularJsonAndProjects)(projectsConfigurations, this.root);
        }
        this.cachedProjectsConfig = {
            version: 2,
            projects: this.mergeTargetDefaultsIntoProjectDescriptions(projectsConfigurations, nxJson),
        };
        return this.cachedProjectsConfig;
    }
    /**
     * Deprecated. Use readProjectsConfigurations
     */
    readWorkspaceConfiguration(opts) {
        const nxJson = (0, nx_json_1.readNxJson)(this.root);
        return Object.assign(Object.assign({}, this.readProjectsConfigurations(opts)), nxJson);
    }
    mergeTargetDefaultsIntoProjectDescriptions(projects, nxJson) {
        for (const proj of Object.values(projects)) {
            if (proj.targets) {
                for (const targetName of Object.keys(proj.targets)) {
                    const projectTargetDefinition = proj.targets[targetName];
                    const defaults = readTargetDefaultsForTarget(targetName, nxJson.targetDefaults, projectTargetDefinition.executor);
                    if (defaults) {
                        proj.targets[targetName] = mergeTargetConfigurations(proj, targetName, defaults);
                    }
                }
            }
        }
        return projects;
    }
}
exports.Workspaces = Workspaces;
/**
 * Pulled from toFileName in names from @nx/devkit.
 * Todo: Should refactor, not duplicate.
 */
function toProjectName(fileName) {
    const parts = (0, path_1.dirname)(fileName).split(/[\/\\]/g);
    return parts[parts.length - 1].toLowerCase();
}
exports.toProjectName = toProjectName;
/**
 * @deprecated Use getGlobPatternsFromPluginsAsync instead.
 */
function getGlobPatternsFromPlugins(nxJson, paths, root = workspace_root_1.workspaceRoot) {
    const plugins = (0, nx_plugin_1.loadNxPluginsSync)(nxJson === null || nxJson === void 0 ? void 0 : nxJson.plugins, paths, root);
    const patterns = [];
    for (const plugin of plugins) {
        if (!plugin.projectFilePatterns) {
            continue;
        }
        for (const filePattern of plugin.projectFilePatterns) {
            patterns.push('*/**/' + filePattern);
        }
    }
    return patterns;
}
exports.getGlobPatternsFromPlugins = getGlobPatternsFromPlugins;
function getGlobPatternsFromPluginsAsync(nxJson, paths, root = workspace_root_1.workspaceRoot) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const plugins = yield (0, nx_plugin_1.loadNxPlugins)(nxJson === null || nxJson === void 0 ? void 0 : nxJson.plugins, paths, root);
        const patterns = [];
        for (const plugin of plugins) {
            if (!plugin.projectFilePatterns) {
                continue;
            }
            for (const filePattern of plugin.projectFilePatterns) {
                patterns.push('*/**/' + filePattern);
            }
        }
        return patterns;
    });
}
exports.getGlobPatternsFromPluginsAsync = getGlobPatternsFromPluginsAsync;
/**
 * Get the package.json globs from package manager workspaces
 */
function getGlobPatternsFromPackageManagerWorkspaces(root) {
    var _a, _b;
    try {
        const patterns = [];
        const packageJson = (0, fileutils_1.readJsonFile)((0, path_1.join)(root, 'package.json'));
        patterns.push(...normalizePatterns(Array.isArray(packageJson.workspaces)
            ? packageJson.workspaces
            : (_b = (_a = packageJson.workspaces) === null || _a === void 0 ? void 0 : _a.packages) !== null && _b !== void 0 ? _b : []));
        if ((0, fs_1.existsSync)((0, path_1.join)(root, 'pnpm-workspace.yaml'))) {
            try {
                const { packages } = (0, fileutils_1.readYamlFile)((0, path_1.join)(root, 'pnpm-workspace.yaml'));
                patterns.push(...normalizePatterns(packages || []));
            }
            catch (e) {
                output_1.output.warn({
                    title: `${logger_1.NX_PREFIX} Unable to parse pnpm-workspace.yaml`,
                    bodyLines: [e.toString()],
                });
            }
        }
        if ((0, fs_1.existsSync)((0, path_1.join)(root, 'lerna.json'))) {
            try {
                const { packages } = (0, fileutils_1.readJsonFile)((0, path_1.join)(root, 'lerna.json'));
                patterns.push(...normalizePatterns((packages === null || packages === void 0 ? void 0 : packages.length) > 0 ? packages : ['packages/*']));
            }
            catch (e) {
                output_1.output.warn({
                    title: `${logger_1.NX_PREFIX} Unable to parse lerna.json`,
                    bodyLines: [e.toString()],
                });
            }
        }
        // Merge patterns from workspaces definitions
        // TODO(@AgentEnder): update logic after better way to determine root project inclusion
        // Include the root project
        return packageJson.nx ? patterns.concat('package.json') : patterns;
    }
    catch (_c) {
        return [];
    }
}
exports.getGlobPatternsFromPackageManagerWorkspaces = getGlobPatternsFromPackageManagerWorkspaces;
function normalizePatterns(patterns) {
    return patterns.map((pattern) => removeRelativePath(pattern.endsWith('/package.json')
        ? pattern
        : (0, path_2.joinPathFragments)(pattern, 'package.json')));
}
function removeRelativePath(pattern) {
    return pattern.startsWith('./') ? pattern.substring(2) : pattern;
}
/**
 * @description Loops through files and reduces them to 1 file per project.
 * @param files Array of files that may represent projects
 */
function deduplicateProjectFiles(files) {
    const filtered = new Map();
    files.forEach((file) => {
        const projectFolder = (0, path_1.dirname)(file);
        const projectFile = (0, path_1.basename)(file);
        if (filtered.has(projectFolder) && projectFile !== 'project.json')
            return;
        filtered.set(projectFolder, projectFile);
    });
    return Array.from(filtered.entries()).map(([folder, file]) => (0, path_1.join)(folder, file));
}
exports.deduplicateProjectFiles = deduplicateProjectFiles;
function buildProjectConfigurationFromPackageJson(path, packageJson, nxJson) {
    var _a, _b, _c, _d;
    const normalizedPath = path.split('\\').join('/');
    const directory = (0, path_1.dirname)(normalizedPath);
    if (!packageJson.name && directory === '.') {
        throw new Error('Nx requires the root package.json to specify a name if it is being used as an Nx project.');
    }
    let name = (_a = packageJson.name) !== null && _a !== void 0 ? _a : toProjectName(normalizedPath);
    if (nxJson === null || nxJson === void 0 ? void 0 : nxJson.npmScope) {
        const npmPrefix = `@${nxJson.npmScope}/`;
        if (name.startsWith(npmPrefix)) {
            name = name.replace(npmPrefix, '');
        }
    }
    const projectType = ((_b = nxJson === null || nxJson === void 0 ? void 0 : nxJson.workspaceLayout) === null || _b === void 0 ? void 0 : _b.appsDir) != ((_c = nxJson === null || nxJson === void 0 ? void 0 : nxJson.workspaceLayout) === null || _c === void 0 ? void 0 : _c.libsDir) &&
        ((_d = nxJson === null || nxJson === void 0 ? void 0 : nxJson.workspaceLayout) === null || _d === void 0 ? void 0 : _d.appsDir) &&
        directory.startsWith(nxJson.workspaceLayout.appsDir)
        ? 'application'
        : 'library';
    return {
        root: directory,
        sourceRoot: directory,
        name,
        projectType,
    };
}
function inferProjectFromNonStandardFile(file) {
    const directory = (0, path_1.dirname)(file).split('\\').join('/');
    return {
        name: toProjectName(file),
        root: directory,
    };
}
exports.inferProjectFromNonStandardFile = inferProjectFromNonStandardFile;
function buildProjectsConfigurationsFromProjectPaths(nxJson, projectFiles, // making this parameter allows devkit to pick up newly created projects
readJson = (string) => (0, fileutils_1.readJsonFile)(string) // making this an arg allows us to reuse in devkit
) {
    const projects = {};
    for (const file of projectFiles) {
        const directory = (0, path_1.dirname)(file).split('\\').join('/');
        const fileName = (0, path_1.basename)(file);
        if (fileName === 'project.json') {
            //  Nx specific project configuration (`project.json` files) in the same
            // directory as a package.json should overwrite the inferred package.json
            // project configuration.
            const configuration = readJson(file);
            configuration.root = directory;
            let name = configuration.name;
            if (!configuration.name) {
                name = toProjectName(file);
            }
            if (!projects[name]) {
                projects[name] = configuration;
            }
            else {
                logger_1.logger.warn(`Skipping project found at ${directory} since project ${name} already exists at ${projects[name].root}! Specify a unique name for the project to allow Nx to differentiate between the two projects.`);
            }
        }
        else {
            // We can infer projects from package.json files,
            // if a package.json file is in a directory w/o a `project.json` file.
            // this results in targets being inferred by Nx from package scripts,
            // and the root / sourceRoot both being the directory.
            if (fileName === 'package.json') {
                const projectPackageJson = readJson(file);
                const _a = buildProjectConfigurationFromPackageJson(file, projectPackageJson, nxJson), { name } = _a, config = tslib_1.__rest(_a, ["name"]);
                if (!projects[name]) {
                    projects[name] = config;
                }
                else {
                    logger_1.logger.warn(`Skipping project found at ${directory} since project ${name} already exists at ${projects[name].root}! Specify a unique name for the project to allow Nx to differentiate between the two projects.`);
                }
            }
            else {
                // This project was created from an nx plugin.
                // The only thing we know about the file is its location
                const _b = inferProjectFromNonStandardFile(file), { name } = _b, config = tslib_1.__rest(_b, ["name"]);
                if (!projects[name]) {
                    projects[name] = config;
                }
                else {
                    logger_1.logger.warn(`Skipping project inferred from ${file} since project ${name} already exists.`);
                }
            }
        }
    }
    return projects;
}
exports.buildProjectsConfigurationsFromProjectPaths = buildProjectsConfigurationsFromProjectPaths;
function mergeTargetConfigurations(projectConfiguration, target, targetDefaults) {
    var _a, _b;
    const targetConfiguration = (_a = projectConfiguration.targets) === null || _a === void 0 ? void 0 : _a[target];
    if (!targetConfiguration) {
        throw new Error(`Attempted to merge targetDefaults for ${projectConfiguration.name}.${target}, which doesn't exist.`);
    }
    const { configurations: defaultConfigurations, options: defaultOptions } = targetDefaults, defaults = tslib_1.__rest(targetDefaults, ["configurations", "options"]);
    const result = Object.assign(Object.assign({}, defaults), targetConfiguration);
    // Target is "compatible", e.g. executor is defined only once or is the same
    // in both places. This means that it is likely safe to merge options
    if (!targetDefaults.executor ||
        !targetConfiguration.executor ||
        targetDefaults.executor === targetConfiguration.executor) {
        result.options = mergeOptions(defaultOptions, (_b = targetConfiguration.options) !== null && _b !== void 0 ? _b : {}, projectConfiguration, target);
        result.configurations = mergeConfigurations(defaultConfigurations, targetConfiguration.configurations, projectConfiguration, target);
    }
    return result;
}
exports.mergeTargetConfigurations = mergeTargetConfigurations;
function mergeOptions(defaults, options, project, key) {
    return Object.assign(Object.assign({}, resolvePathTokensInOptions(defaults, project, key)), options);
}
function mergeConfigurations(defaultConfigurations, projectDefinedConfigurations, project, targetName) {
    const configurations = Object.assign({}, projectDefinedConfigurations);
    for (const configuration in defaultConfigurations) {
        configurations[configuration] = mergeOptions(defaultConfigurations[configuration], configurations[configuration], project, `${targetName}.${configuration}`);
    }
    return configurations;
}
function resolvePathTokensInOptions(object, project, key) {
    const result = Array.isArray(object) ? [...object] : Object.assign({}, object);
    for (let [opt, value] of Object.entries(object !== null && object !== void 0 ? object : {})) {
        if (typeof value === 'string') {
            if (value.startsWith('{workspaceRoot}/')) {
                value = value.replace(/^\{workspaceRoot\}\//, '');
            }
            if (value.includes('{workspaceRoot}')) {
                throw new Error(`${logger_1.NX_PREFIX} The {workspaceRoot} token is only valid at the beginning of an option. (${key})`);
            }
            value = value.replace(/\{projectRoot\}/g, project.root);
            result[opt] = value.replace(/\{projectName\}/g, project.name);
        }
        else if (typeof value === 'object' && value) {
            result[opt] = resolvePathTokensInOptions(value, project, [key, opt].join('.'));
        }
    }
    return result;
}
function readTargetDefaultsForTarget(targetName, targetDefaults, executor) {
    if (executor) {
        // If an executor is defined in project.json, defaults should be read
        // from the most specific key that matches that executor.
        // e.g. If executor === run-commands, and the target is named build:
        // Use, use nx:run-commands if it is present
        // If not, use build if it is present.
        const key = [executor, targetName].find((x) => targetDefaults === null || targetDefaults === void 0 ? void 0 : targetDefaults[x]);
        return key ? targetDefaults === null || targetDefaults === void 0 ? void 0 : targetDefaults[key] : null;
    }
    else {
        // If the executor is not defined, the only key we have is the target name.
        return targetDefaults === null || targetDefaults === void 0 ? void 0 : targetDefaults[targetName];
    }
}
exports.readTargetDefaultsForTarget = readTargetDefaultsForTarget;
// we have to do it this way to preserve the order of properties
// not to screw up the formatting
function renamePropertyWithStableKeys(obj, from, to) {
    const copy = Object.assign({}, obj);
    Object.keys(obj).forEach((k) => {
        delete obj[k];
    });
    Object.keys(copy).forEach((k) => {
        if (k === from) {
            obj[to] = copy[k];
        }
        else {
            obj[k] = copy[k];
        }
    });
}
exports.renamePropertyWithStableKeys = renamePropertyWithStableKeys;
